import re
from utils.llm_client import LLMClient
import textwrap

class CoderAgent:

    def __init__(self, llm_client: LLMClient):
        self.llm = llm_client

    def code(self, prompt: str, plan: str = None, current_code: str = "", feedback: str = "") -> str:
        """
        Generate or fix code. 
        'plan' is optional. If None, the agent codes directly from the prompt.
        """
        

        signature_instruction = "Infer the function signature directly from the PROBLEM description."
        
        if plan:
            extracted_sig = self._extract_signature_from_plan(plan)
            if extracted_sig:
                signature_instruction = f"Use exactly this function signature: {extracted_sig}"

        if current_code and feedback:
            full_prompt = self._fix_prompt_template(
                prompt=prompt,
                plan=plan,
                current_code=current_code,
                feedback=feedback,
                signature_instruction=signature_instruction
            )
            temp = 0.4
        else:
            full_prompt = self._generate_prompt_template(
                prompt=prompt,
                plan=plan,
                signature_instruction=signature_instruction
            )
            temp = 0.2
        
        response = self.llm.generate_response(
            full_prompt,
            temperature=temp,
            max_new_tokens=1024
        )
        
        if isinstance(response, tuple):
            response = response[0]

        return self._extract_clean_code(response)

    def _extract_signature_from_plan(self, plan: str) -> str:
        if not plan:
            return ""
        
        match = re.search(r"SIGNATURE:\s*(def\s+\w+\s*\(.*?\))", plan, re.DOTALL)
        if match:
            return match.group(1).strip()
        return ""

    def _generate_prompt_template(self, *, prompt: str, plan: str, signature_instruction: str) -> str:
        
        if plan:
            plan_section = f"""
            ### THE PLAN TO FOLLOW
            This plan was generated by the Planner Agent. You must implement it strictly:
            {plan}
            """
        else:
            plan_section = """
            ### STRATEGY
            Analyze the problem and implement the most efficient solution directly.
            """

        return f"""### ROLE: EXPERT PYTHON IMPLEMENTER
        You are the "Coding Component" in a system. 
        Your specific job is to write high-performance, bug-free Python code.

        ### TASK SPECIFICATION
        Write a complete, self-contained Python solution for the following problem.
        {prompt}

        {plan_section}

        ### COMPILER & STYLE REQUIREMENTS (STRICT)
        1. **Entry Point**: {signature_instruction}
        2. **Dependencies**: Include ALL necessary standard library imports at the top.
        3. **Purity**: Output ONLY valid Python code. No markdown, no comments, no explanations.
        4. **Logic Integrity**: Ensure all edge cases are handled.
        
        ### ARCHITECTURAL GOALS:
        1. **Efficiency**: Use optimal algorithms. Minimize time and space complexity.
        2. **Maintainability**: Ensure clean, readable logic.
        
        ### OUTPUT GENERATION
        ```python
        """

    def _fix_prompt_template(self, *, prompt: str, plan: str, current_code: str, feedback: str, signature_instruction: str) -> str:
        
        if plan:
            plan_section = f"""
            ### ORIGINAL PLAN
            {plan}
            (Follow the plan ONLY where it does not conflict with the Fixes below)
            """
        else:
            plan_section = ""

        return f"""### SYSTEM INSTRUCTION
        You are a Python Code Generation Engine.
        You are fixing a previous implementation based on Reviewer feedback.

        ### MANDATORY TASK
        1. **Signature**: {signature_instruction}
        2. Incorporate the Reviewer Fixes to repair the Broken Code.

        ### ARCHITECTURAL GOALS:
        1. **Efficiency**: Use optimal algorithms.
        2. **Maintainability**: Ensure clean, readable logic.

        ### REVIEWER FIXES (PRIORITY)
        {feedback}

        {plan_section}

        ### BROKEN CODE TO REPAIR
        {current_code}

        ### OUTPUT REQUIREMENTS
        - Include ALL necessary imports.
        - Output ONLY valid Python code.
        - No markdown blocks (no ```python), no explanations.
        - Start directly with the code.

        ### CORRECTED CODE:
        ```python
        """

    def _extract_clean_code(self, response: str) -> str:
        match = re.search(r"```python\s*(.*?)```", response, re.DOTALL | re.IGNORECASE)
        if match:
            return match.group(1).strip()
        
        match = re.search(r"```\s*(.*?)```", response, re.DOTALL)
        if match:
            return match.group(1).strip()
            
        lines = response.splitlines()
        code_lines = []
        started = False
        keywords = ("def ", "import ", "from ", "class ")
        
        for line in lines:
            if any(line.strip().startswith(k) for k in keywords):
                started = True
            if started:
                code_lines.append(line)
        
        if code_lines:
            return "\n".join(code_lines).strip()
            
        return response.strip()